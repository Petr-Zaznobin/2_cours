//построить оставное дерево, то есть вершины, которые еще не присоеденены присоединяются к дереву
#include <iostream>
#include <time.h>
using namespace std;

class graph {
private:
	int n;
	double p;
	int count_full = 0;
	int** mat;
public:
	graph(int n_, double p_) {
		n = n_;
		p = p_;
	}
	~graph() {
		n = 0;
		p = 0;
		delete[]mat;
	}
	void generate() {
		double maxPeps = p;
		double tmp = 0.0;
		mat = new int*[(n+1)];
		for (int i = 0; i < (n + 1); i++) {
			mat[i] = new int[(n + 1)];
		}
		for (int i = 0; i < n+1; i++) {
			for (int j = 0; j < n+1; j++) {
				mat[i][j] = 0;
			}
		}
		for (int i = 1; i < (n+1); i++) {
			srand(time(NULL));
			int num = (rand() % 100);
			mat[0][i] = num;
			mat[i][0] = num;
			count_full++;
		}
		while (maxPeps>tmp) {	//n(n+1) - максимальное количество ребер на данном количестве вершин
			srand(time(NULL));
			int ind = rand() % (n+1);
			int ind2 = rand() % (n + 1);
			if (mat[ind][ind2] == 0 && ind != ind2) {
				int num = rand() % 100;
				mat[ind][ind2] = num;
				mat[ind2][ind] = num;
				count_full++;
			}
			tmp = double(count_full) / double((n * (n + 1)/2));
		}
	}
	void printMat() {
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				cout << mat[i][j] << " ";
			}
			cout << "\n";
		}
	}
};


int main() {
	graph A(15, 0.4);
	A.generate();
	A.printMat();
}
